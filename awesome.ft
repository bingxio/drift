// Drift
// GPL 3.0 License - bingxio <3106740988@qq.com>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef enum { 
	EOH,	   LITERAL,   NUMBER,    STRING,  CHAR,      FLOAT,   
	ADD,       SUB,       MUL,       DIV,     SUR,       AS_ADD,
	AS_SUB,    AS_MUL,    AS_DIV,    AS_SUR,  R_ARROW,   L_ARROW, 
	DOT,	   COMMA,     COLON,     EQ,      SEMICOLON, GREATER, 
	LESS,      GR_EQ,     LE_EQ,     ADDR,	  OR,        BANG,  
	BANG_EQ,   EQ_EQ,     L_BRACE,   R_BRACE, L_PAREN,   R_PAREN,
	L_BRACKET, R_BRACKET, UNDERLINE, DEF,     RET, 	     FOR,
	AOP,       IF,        EF,        NF,      NEW, 	     OUT,
	GO, 	   MOD,       USE
} token_kind;

const char *keyword[12] = {
	"def", "ret", "for", "aop", "if",  "ef", 
	"nf",  "new", "out", "go",  "mod", "use"
};

typedef struct { token_kind kind; const char *literal; int line; int off; } token;
typedef struct { int len; int cap; token *tokens; } lexer_result;

bool is_space(char c) { return c == ' ' || c == '\t' || c == '\n' || c == '\r'; }
bool is_digit(char c) { return c >= '0' && c <= '9'; }
bool is_ident(char c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

token_kind to_keyword(const char *literal) {
	for (int i = 0; i < 12; i ++) {
		if (strcmp(literal, keyword[i]) == 0) {
			if (i ==  0) return DEF; if (i ==  1) return RET;
			if (i ==  2) return FOR; if (i ==  3) return AOP;
			if (i ==  4) return IF;  if (i ==  5) return EF;
			if (i ==  6) return NF;  if (i ==  7) return NEW;
			if (i ==  8) return OUT; if (i ==  9) return GO;
			if (i == 10) return MOD; if (i == 11) return USE;
		}
	}
	return LITERAL;
}

token new_token(token_kind k, const char *literal, int line, int off) {
	token t = {.kind = k, .literal = literal, .line = line, .off = off};
	return t;
}

void *append(void *ptr, int *len, int *cap, size_t size) {
	if (*cap == 0 || *len + 1 > *cap) {
		if (*cap == 0) {
			*cap = 4;
		} else {
			*cap *= 2;
		}
		ptr = realloc(ptr, size * (*cap));
	}
	return ptr;
}

void append_token(lexer_result *lex, token tok) {
	lex->tokens = append(lex->tokens, &lex->len, &lex->cap, sizeof(token));
	lex->tokens[lex->len++] = tok;
}

bool next(const char *buf, int *p, char c) {
	if (buf[*p + 1] == c) {
		*p += 2;
		return true;
	}
	(*p) ++;
	return false;
}

lexer_result *lexer(const char *buf, int fsize) {
	lexer_result *l = (lexer_result *) malloc(sizeof(lexer_result));
	bool new_line = true;
	for (int i = 0, line = 1, off = 0; i < fsize;) {
		char c = buf[i];
		while (is_space(c)) {
			if (c == '\n') {
				line ++;
				off = -1;
				new_line = true;
			}
			c = buf[++ i];
			if (new_line) off ++;
		}
		if (new_line) new_line = false;
		if (is_digit(c)) {
			int p = 0;
			bool f = false;
			while (is_digit(c) || c == '.') {
				if (c == '.') f = true;
				p ++;
				c = buf[++ i];
			}
			char *literal = (char *) malloc(p * sizeof(char));
			for (int x = 0, j = p; x < j; x ++) {
				literal[x] = buf[i - p];
				p --;
			}
			append_token(l, new_token(f ? FLOAT : NUMBER, literal, line, off));
			continue;
		}
		if (is_ident(c)) {
			int p = 0;
			while (is_ident(c)) {
				p ++;
				c = buf[++ i];
			}
			char *literal = (char *) malloc(p * sizeof(char));
			for (int x = 0, j = p; x < j; x ++) {
				literal[x] = buf[i - p];
				p --;
			}
			append_token(l, new_token(
						to_keyword(literal), literal, line, off));
			continue;
		}
		token t = {.line = line, .off = off};
		switch (c) {
			case '+':
				if (next(buf, &i, '=')) t.kind = AS_ADD;
				else t.kind = ADD;
				break;
			case '-':
				if (next(buf, &i, '=')) t.kind = AS_SUB;
				else {
					if (buf[i] == '>') {
						t.kind = R_ARROW;
						i ++;
					} else t.kind = SUB;
				}
				break;
			case '*':
				if (next(buf, &i, '=')) t.kind = AS_MUL;
				else t.kind = MUL;
				break;
			case '/':
				if (next(buf, &i, '=')) t.kind = AS_DIV;
				else t.kind = DIV;
				break;
			case '%':
				if (next(buf, &i, '=')) t.kind = AS_SUR;
				else t.kind = SUR;
				break;
			case '<':
				if (next(buf, &i, '=')) t.kind = LE_EQ;
				else {
					if (buf[i] == '-') {
						t.kind = L_ARROW;
						i ++;
					} else t.kind = LESS;
				}
				break;
			case '>':
				if (next(buf, &i, '=')) t.kind = GR_EQ;
				else t.kind = GREATER;
				break;
			case ' ':
			case '\t':
			case '\r':
			case '\n':
			case '\0':
				continue;
			case '#':
				while (buf[++ i] != '\n');
				continue;
			case '\'': {
				i ++;
				char *literal = (char *) malloc(sizeof(char));
				literal[0] = buf[i ++];
				c = buf[i];
				if (c != '\'') {
					fprintf(stderr, 
						"<lexer %d>: missing single quotation mark to the right.\n",
						line);
					exit(EXIT_FAILURE);
				} else {
					i += 2;
				}
				t.kind = CHAR; t.literal = literal;
			}
				break;
			case '"': {
				c = buf[++ i];
				int p = 0;
				while (c != '"') {
					c = buf[++ i];
					p ++;
					if (i == fsize) {
						fprintf(stderr,
							"<lexer %d>: missing closing double quote.\n", line);
						exit(EXIT_FAILURE);
					}
				}
				char *literal = (char *) malloc(p * sizeof(char));
				for (int x = 0, j = p; x < j; x ++) {
					literal[x] = buf[i - p];
					p --;
				}
				i ++;
				t.kind = STRING, t.literal = literal;
			}
				break;
			case '.':
				i ++;
				t.kind = DOT;
				break;
			case ',':
				i ++;
				t.kind = COMMA;
				break;
			case ':':
				i ++;
				t.kind = COLON;
				break;
			case '=':
				if (next(buf, &i, '=')) t.kind = EQ_EQ;
				else t.kind = EQ;
			case ';':
				i ++;
				t.kind = SEMICOLON;
				break;
			case '&':
				i ++;
				t.kind = ADDR;
				break;
			case '|':
				i ++;
				t.kind = OR;
				break;
			case '!':
				if (next(buf, &i, '=')) t.kind = BANG_EQ;
				else t.kind = BANG;
				break;
			case '{':
				i ++;
				t.kind = L_BRACE;
				break;
			case '}':
				i ++;
				t.kind = R_BRACE;
				break;
			case '[':
				i ++;
				t.kind = L_BRACKET;
				break;
			case ']':
				i ++;
				t.kind = R_BRACKET;
				break;
			case '(':
				i ++;
				t.kind = L_PAREN;
				break;
			case ')':
				i ++;
				t.kind = R_PAREN;
				break;
			default:
				fprintf(stderr, "<lexer %d>: Unknown character '%c'.\n",
					line, c);
				exit(EXIT_FAILURE);
		}
		append_token(l, t);
	}
	append_token(l, new_token(EOH, "EOH", l->tokens[l->len - 1].line + 1, 0));
	return l;
}

int main(int argc, char **argv) {
	if (argc < 2) {
		printf("usage: ./drift (file)\n");
		exit(EXIT_FAILURE);
	}
	const char *path = argv[1];
	FILE *fp = fopen(path, "r");
	if (fp == NULL) {
		printf("<compiler>: Failed to read buffer of file: %s\n", path);
		exit(EXIT_FAILURE);
	}

	fseek(fp, 0, SEEK_END);
	int fsize = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	char *buf = (char *) malloc(fsize * sizeof(char));
	
	fread(buf, fsize, sizeof(char), fp);
	buf[fsize] = '\0';

	lexer_result *lex = lexer(buf, fsize);
	for (int i = 0; i < lex->len; i ++) {
		token t = lex->tokens[i];
		printf("%-5d %-20s %-10d %d\n", t.kind, t.literal, t.line, t.off);
	}
	
	fclose(fp);
	return 0;
}
